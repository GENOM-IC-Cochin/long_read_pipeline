---
title: "HIV Long Read"
author: "Paul Etheimer"
date: '2023-03-09'
output: html_document
params:
  gtf: ../quants_human/00_20200818_NLGV_4GSTm_deltaTat_A2020_pass_barcode07_human_s/00_20200818_NLGV_4GSTm_deltaTat_A2020_pass_barcode07_human_s.transcript_models.gtf
  quants: ../quants_human/00_20200818_NLGV_4GSTm_deltaTat_A2020_pass_barcode07_human_s/00_20200818_NLGV_4GSTm_deltaTat_A2020_pass_barcode07_human_s.transcript_model_grouped_counts.tsv
  design: ../deseq2_NLGV_4GSTm_deltaTat_A2020-deseq2Design.txt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE,
                      echo=FALSE,
                      warning=FALSE
                      )
```
```{r libraries}
library(readr)
library(dplyr)
library(tidyr)
library(purrr)
library(tibble)
library(ggplot2)
library(stringr)
library(aggregation)
library(hexbin)

library(GenomicFeatures)
library(vsn)
library(DESeq2)
library(DEXSeq)
library(DRIMSeq)
library(biomaRt)
library(IsoformSwitchAnalyzeR)
library(BSgenome.Hsapiens.UCSC.hg38)

```
```{css}
div.figure {
  display: block;
  text-align: center;
}
p.caption {
  font-size: 0.8em;
}

```


<!-- TODO : implémenter stageR pour DEXSeq -->
<!-- TODO : Faire une DGE classique pour la comparer à la sortie de Lancaster -->


```{r}
rld_pca <- function(rld, config, ntop = 500) {
  rv <- matrixStats::rowVars(assay(rld))
  selected_genes <- order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))]
  mat <- t(assay(rld)[selected_genes, ])
  pc <- prcomp(mat)
  eig <- (pc$sdev)^2
  variance <- eig * 100 / sum(eig)

  PCAdata <- as.data.frame(pc$x)
# Join with condition, on name, to be sure of matches between condition and sample
  PCAdata <- PCAdata %>%
    tibble::rownames_to_column(var = "sampleID") %>%
    inner_join(config, by = "sampleID") %>%
    tibble::column_to_rownames(var = "sampleID")
  list("data" = PCAdata, "variance" = variance)
}

plot_isoforms <- function(matrix_tx, txdf, genes) {
  plot_data <- matrix_tx %>%
    left_join(txdf %>% dplyr::rename("isoform_id" = "TXNAME", "gene_id" = "GENEID"), by = "isoform_id") %>%
    dplyr::filter(gene_id %in% genes) %>%
    mutate(delta = rowMeans(dplyr::select(., contains("delta"))),
           control = rowMeans(dplyr::select(., -contains("delta") & where(is.numeric)))) %>%
    dplyr::select(delta, control, isoform_id, gene_id) %>%
    pivot_longer(!c(isoform_id, gene_id), names_to = "condition", values_to = "mean")
    
  plot_tx <- ggplot(plot_data, aes(x = isoform_id, y = mean, fill = condition)) +
    geom_bar(stat = "identity", position = "dodge") 
  if(length(genes) == 1) {
    plot_tx <- plot_tx +
      scale_x_discrete(guide = guide_axis(n.dodge = 2)) +
      facet_wrap(~gene_id, scales = "free_x")
  } else if (length(genes) < 8) {
    plot_tx <- plot_tx +
      scale_x_discrete(guide = guide_axis(angle = 45)) +
      theme(axis.text.x = element_text(size = 5)) +
      facet_wrap(~gene_id, scales = "free")
  } else {
    plot_tx <- plot_tx +
      theme(axis.text.x = element_blank()) +
      facet_wrap(~gene_id, scales = "free")
  }
  
  plot_tx
}
```



## Introduction

Ce projet a pour but d'explorer plusieurs méthodes d'analyse d'analyse différentielle de l'épissage entre deux conditions, avec >= 3 réplicats. Les données de comptages sont obtenues grace à du séquençage long read sur ONT. Cette version explore les données de Corentin Aubé sur deux infections de cellules par deux VIH différents, séquencées en MinION. Il doit servir de *toy dataset* pour les données du futur projet de l'équipe de Sarah Gallois-Montbrun.

J'ai relevé trois niveaux d'analyse pour étudier les différences au niveau des transcrit entre deux conditions : 
- étudier le DTU, *Differential Transcript Usage*, qui consiste à observer les changements dans l'expression relative entre des isoformes d'un gène. Une limite potentielle est que si le test est implémenté sous la forme de ratio, cette méthode est sensible à des variations dans les isoforms de faible expression.
- étudier le DTE, *Differential Transcript Expression*, c'est à dire comme l'analyse classique mais au niveau transcrit. Les limitations de cette méthode est le manque potentiel de puissance statistique (augmentation du nombre de variables par rapport au niveau gène, sans augmenter le nombre de réplicats).
- étudier le GDE, *Gene differential expression*, comme défini par Lior Pachter [ici](https://liorpachter.wordpress.com/2018/02/15/gde%C2%B2-dge%C2%B2-dtu%C2%B2-dte%E2%82%81%C2%B2-dte%E2%82%82%C2%B2/), mais qu'il est impossible d'appliquer dans le contexte du bulk RNA-seq.

L'inférence statistique, pour l'heure en test, utilise tour à tour trois méthodes : 
- DEXSeq après un filtre avec DRIMSeq, qui est une méthode de *Differential Transcript Usage*. Permet de rejeter l'hypothèse que la répartition entre les isoformes est inchangée entre les deux conditions.
- Une méthode d'aggrégation DTE->G, qui utilise la méthode de Lancaster pour aggréger les résultats de DTE au niveau gène. Ceci donne un avantage d'interprétabilité (il est plus facile d'avoir de l'information d'annotation au niveau du gène), et qui permet, si la *p-value* ajustée est inférieure à un seuil déterminé, de rejeter l'hypothèse qu'aucun isoforme ne bouge entre les deux conditions. C'est une hypothèse nulle plus forte et donc plus intéressante à rejeter que la précédente, en revanche, en la rejetant on n'a pas l'information sur quel isoforme a provoqué son rejet.
- Finalement il existe aussi l'implémentation IsoformSwichAnalyzeR de la première méthode. Il est difficile de vérifier si elle est exactement identique (elle semble utiliser des fractions plutôt que des différences), mais il est certain qu'elle possède un filtre différent.

## EDA
La première étape est une exploration du jeu de données.
```{r}
samplesheet <- read_tsv(params$design)
matrix_tx <- read_tsv(params$quants)
samplesheet <- tibble(samplesheet, "tx_mat_name" = colnames(matrix_tx)[-1])
colnames(matrix_tx) <- c("isoform_id", samplesheet$Description)
design_matrix <- samplesheet %>% dplyr::select(Condition, Description) %>% dplyr::rename(sampleID = Description, condition = Condition)
```
```{r}
matrix_tx %>%
  pivot_longer(!isoform_id, names_to = "sampleID") %>%
  left_join(design_matrix, by = "sampleID") %>%
  ggplot(aes(x = sampleID, y = value, fill = condition)) +
  geom_violin() +
  scale_y_log10()
```


```{r}
exploratory_dds <- DESeqDataSetFromMatrix(round(matrix_tx %>% column_to_rownames("isoform_id") %>% as.matrix),
                                          colData = design_matrix %>% column_to_rownames("sampleID"),
                                          ~ condition)
exploratory_dds <- estimateSizeFactors(exploratory_dds)
```


<!-- Ces distributions semblent relativement proche. Nous pouvons également nous intéresser au lien entre la variance et la moyenne, problème bien connu des données de RNA-Seq au niveau gène. -->
<!-- ```{r} -->
<!-- # DESeq2::plotDispEsts(exploratory_dds, ymin = 0e-08) -->
<!-- # Error in class(x) <- unique.default(c("AsIs", oldClass(x))) :  -->
<!-- #   attempt to set an attribute on NULL -->
<!-- ``` -->

<!-- ```{r} -->
<!-- library(vsn) -->
<!-- library(hexbin) -->
<!-- meanSdPlot(assay(normTransform(exploratory_dds))) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- meanSdPlot(assay(rlog(exploratory_dds))) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- meanSdPlot(assay(vst(exploratory_dds))) -->
<!-- ``` -->

<!-- Ces trois visualisations nous indique que le lien de la variance avec la moyenne de nos comptes de transcrits est assez faible quelque soit la transformation, et que la transformation la plus pertinente semble la transformation log la plus classique -->

```{r}
log_tr <- normTransform(exploratory_dds)
pca_data <- rld_pca(log_tr, design_matrix)#, nrow(log_tr))
```

```{r pca_counts}
plot_res <- ggplot(
  pca_data$data,
  aes(
    x = PC1,
    y = PC2,
    label = rownames(pca_data$data)
  )
) +
  ylab(paste0("PC2: ", round(pca_data$variance[2], 1), "% variance")) +
  xlab(paste0("PC1: ", round(pca_data$variance[1], 1), "% variance")) +
  coord_fixed() +
  geom_point(aes(color = condition), size = 5)
plot_res
```

On observe sur cette PCA que les deux conditions semblent malheureusement se recouvrir, notamment à cause d'un échantillon particulier du groupe contrôle. Si dans un cas général nous ne poursuivrions peut-être pas l'analyse, ici comme le but est d'écrire un modèle d'analyse, nous allons continuer.

## DTU avec DEXSeq et DRIMSeq

### Filtrer avec DRIMSeq

La première analyse statistique des gènes exhibant un *differential transcript usage* est basée sur [Love et al.](https://f1000research.com/articles/7-952/v3). Ce workflow utilise DRIMSeq pour filtrer les transcrits, avant d'utiliser DEXSeq pour l'inférence.

La première étape de ce pipeline implique de construire un lien entre noms de transcrits, que nous avons, et noms de gènes. Ceci est compliqué par le fait que nous avons utilisé la découverte de transcrit avec Isoquant, ce qui fait qu'un simple fichier d'annotation ne suffit pas. Donc nous allons utiliser le package `GenomicFeatures` pour importer le fichier gtf construit par Isoquant, sous la forme d'un objet TxDb. 

```{r}
gtf <- params$gtf
txdb_filename <- "transcript_models.sqlite"
txdb <- makeTxDbFromGFF(gtf)
invisible(saveDb(txdb, txdb_filename))
txdf <- AnnotationDbi::select(txdb, keys(txdb, "GENEID"), "TXNAME", "GENEID")
# tab <- table(txdf$GENEID) not used?
# txdf$ntx <- tab[match(txdf$GENEID, names(tab))]
```

```{r}
# sanity checks from paper
# cts_matrix <- matrix_tx %>% column_to_rownames("isoform_id") %>% as.matrix()
# all(rownames(cts_matrix) %in% txdf$TXNAME)
# txdf <- txdf[match(rownames(cts_matrix),txdf$TXNAME),]
# all(rownames(cts_matrix) == txdf$TXNAME)
counts <- left_join(
    matrix_tx %>% dplyr::rename("feature_id" = "isoform_id"),
    txdf %>% dplyr::rename("feature_id" = "TXNAME"),
    by = "feature_id") %>%
  dplyr::rename("gene_id" = "GENEID") %>%
  relocate(gene_id, .after = feature_id)
```
On commence donc par filter les données via DRIMSeq. Il y a trois filtres :
- minimum de comptage de transcrit de 10 dans au moins 3 échantillons
- minimum de 10% du transcrit relatif au gène dans au moins 3 échantillons
- minimum de comptage du gène de 10 dans les 6 échantillons.

Ce sont les filtres du workflow modèle, mais nous allons utiliser 3, 10% et 3 dans notre cas car il y a très peu de profondeur. Sur des données Promethion, nous pourrions utiliser plus de 
```{r}
drim <- dmDSdata(counts = counts %>% as.data.frame(),
                 samples = design_matrix %>% dplyr::rename("sample_id" = "sampleID") %>% as.data.frame())
drim <- dmFilter(
  drim,
  min_samps_feature_expr = 3, min_feature_expr = 3,
  min_samps_feature_prop = 3, min_feature_prop = 0.1,
  min_samps_gene_expr = 6, min_gene_expr = 3
)
```

Le nombre de gènes est très fortement diminué, divisé par ~ 5, malgré des filtres permissifs. Mais sur des données plus profondes, cela pourrait être moins drastique. Les gènes n'ayant qu'un isoform sont évidemment éliminés.

Le worklow continue en utilisant DRIMSeq, mais nous n'utiliserons que DEXSeq pour la partie inférence.

### Inférence avec DEXSeq

```{r}
sample_data <- DRIMSeq::samples(drim)
count_data <- round(as.matrix(counts(drim)[, -c(1, 2)]))
dex <- DEXSeqDataSet(
  countData = count_data,
  sampleData = sample_data,
  design = ~ sample + exon + condition:exon,
  featureID = counts(drim)$feature_id,
  groupID = counts(drim)$gene_id
)
```
```{r}
dex <- DEXSeq::estimateSizeFactors(dex)
dex <- DEXSeq::estimateDispersions(dex)
dex <- DEXSeq::testForDEU(dex, reducedModel = ~ sample + exon)
```

 
```{r}
dex_res <- DEXSeqResults(dex, independentFiltering = FALSE)
qval <- perGeneQValue(dex_res)
dex_res_g <- data.frame(gene = names(qval), qval)
```
```{r}
# Pour avoir la liste des transcrits, mais pourquoi pvalue et not padj??-> pour stageR?
columns <- c("featureID","groupID","pvalue")
dxr_sub <- as.data.frame(dex_res[,columns])
head(dxr_sub)
```


## Inférence niveau transcrit avec aggrégation via Lancaster
Cette version de l'inférence statistique se base sur l'article de Yi et al *"Gene-level differential analysis at transcript-level resolution"*. Il s'agit de faire une analyse tout d'abord au niveau transcrit via DESeq2 (sleuth dans l'article, mais le code est adapté de leur comparaison avec DESeq2), et ensuite de l'aggréger au niveau gène via la méthode de Lancaster, qui semble selon l'article plus adapté que la méthode de Sirak, qui est celle de la méthode `perGeneQValue` de DEXSeq. Cela permet entre autre de disposer d'une liste de gènes **classés** par ordre de *perturbation*, ce dont on ne disposerait pas si on utilisait uniquement la liste de transcrits.

Elle permet d'avoir également les données au niveau gènes, ce qu'on a avec DEXSeq via la perGeneQValue, mais celle-ci est critiquée par les auteurs. Je trouve cette approche plutôt élégante. Elle se rapproche de mon idée initiale de croiser DTE et DGE. Elle permet aussi de récupérer les gènes monotranscrits, notamment ceux nouvellement identifiés par Isoquant.

Sans utiliser le filtre DRIMSeq, on obtient le résultat suivant : 

```{r}
agg_dds <- DESeqDataSetFromMatrix(round(matrix_tx %>% column_to_rownames("isoform_id") %>% as.matrix),
                                          colData = design_matrix %>% column_to_rownames("sampleID"),
                                          ~ condition)
agg_dds <- DESeq(agg_dds)
agg_res <- as.data.frame(DESeq2::results(agg_dds))
```

```{r}
agg_res$transcript <- rownames(agg_res)
agg_res_joined <- left_join(agg_res, txdf %>% dplyr::rename("transcript" = "TXNAME", "gene" = "GENEID"), by = "transcript")
agg_res_joined <- dplyr::select(agg_res_joined, gene, pvalue, baseMean)
agg_summary <- agg_res_joined %>% group_by(gene) %>%
  summarise(n = n(),
            lancaster_pval = lancaster(pvalue, baseMean),
            sidak_pval = sidak(pvalue))
agg_summary$lancaster_padj <- p.adjust(agg_summary$lancaster_pval, "BH")
```

Comme cette méthode aggrège les résultats au niveau du gène, elle permet par la suite de faire de l'enrichissement sur cette liste et identifier ainsi des groupes perturbés, plutôt qu'uniquement différentiellement exprimés. C'est implémenté dans le papier de cette méthode.
 On peut également utiliser en entrée les transcrits filtrés par DRIMSeq, mais nous perdons donc dans ce cas-ci les gènes possédant un unique transcrit.
  
```{r}
agg_dds_filter <- DESeqDataSetFromMatrix(round(counts(drim) %>% column_to_rownames("feature_id") %>% dplyr::select(-gene_id)),
                                          colData = design_matrix %>% column_to_rownames("sampleID"),
                                          ~ condition)
agg_dds_filter <- DESeq(agg_dds_filter)
agg_res_filter <- as.data.frame(DESeq2::results(agg_dds_filter))
```
```{r}
agg_res_filter$transcript <- rownames(agg_res_filter)
agg_res_filter_joined <- left_join(agg_res_filter, txdf %>% dplyr::rename("transcript" = "TXNAME", "gene" = "GENEID"), by = "transcript")
agg_res_filter_joined <- dplyr::select(agg_res_filter_joined, gene, pvalue, baseMean)
agg_filter_summary <- agg_res_filter_joined %>% group_by(gene) %>%
  summarise(n = n(),
            lancaster_pval = lancaster(pvalue, baseMean),
            sidak_pval = sidak(pvalue))
agg_filter_summary$lancaster_padj <- p.adjust(agg_filter_summary$lancaster_pval, "BH")
```

On observe (heureusement) une assez forte correspondance entre les gènes identifiés en partant des deux jeux de données. On note qu'en utilisant les données filtrées

## Inférence avec IsoformSwitchAnalyzeR

Normalement, cette méthode devrait donner des résultats identiques à DEXSeq en mode transcrit (puisque c'est un wrapper de cette méthode), la première méthode testée ici, si l'on utilise des filtres identiques (ce qui est presque possible). Ses auteurs mettent en avant que c'est plutôt une méthode pour l'analyse downstream que pour l'inférence statistique, qui répond à la question : que conclure une fois que l'on a identifié des transcrits utilisés différemment? Ce package pourrait nous servir afin de compléter l'information fournie par l'enrichissement obtenu après DESeq2 + Lancaster.

```{r, cache = TRUE}

switchList <- invisible(importRdata(
  isoformCountMatrix = matrix_tx,
  designMatrix = design_matrix,
  isoformExonAnnoation = params$gtf
))
switchListFiltered <- invisible(preFilter(
  switchAnalyzeRlist = switchList,
  geneExpressionCutoff = 1,
  isoformExpressionCutoff = 1,
  IFcutoff = 0.1,
  removeSingleIsoformGenes = TRUE
))
switchListAnalyzed <- invisible(isoformSwitchTestDEXSeq(
  switchAnalyzeRlist = switchListFiltered,
  reduceToSwitchingGenes = TRUE
))

isar_result <- left_join(switchListAnalyzed$isoformSwitchAnalysis,
                         txdf %>% dplyr::rename("gene_id" = "GENEID", "isoform_id" = "TXNAME"),
                         by = "isoform_id")
```

## Discussion
Pour cette analyse, on observe que chaque méthode donne des résultats différents. Ceci est cependant attendu, car l'EDA, en particulier la PCA, indiquait qu'il y avait un faible regroupement des échantillons selon leur condition. De plus, étant donné le faible nombre de transcrits exprimés significativement (autour de 7000 après un filtre permissif avec DEXSeq), on pouvait s'attendre à une certaine variabilité entre les méthodes qui peuvent être sensibles différement aux outliers.

On observe un gène identifié par DEXSeq après filtre par DRIMSeq, 4 par la méthode d'aggrégation de Lancaster (non-filtrée), puis 6 par la même méthode en utilisant le filtre DRIMSeq, et enfin 3 gènes selon IsoformSwitchAnalyzeR. 

Le gène de DEXSeq est retrouvé IsoformSwichAnalyzeR, ce qui est normal si l'on tient compte du fait qu'IsoformSwitchAnalyzeR utilise DEXSeq en mode transcrit, la seule étape différente étant normalement le filtre préalable. Il faut également tenir compte du fait qu'ISAR et DEXSeq se concentre sur le DTU, mais que pour le second nous utilisons sa fonction `perGeneQValue`, qui permet d'identifier quels gènes ont au moins un transcrit dont la proportion change entre les conditions. La méthode d'aggrégation utilisée, Šidák, considère que les tests individuels sur les transcrits sont indépendants, une hypothèse que ne fait pas de la méthode Lancaster. Celle-ci fait ressortir des gènes différents des deux autres méthodes. Selon l'article qui la présente, cette méthode d'aggrégation est censée faire ressortir les gènes pour lesquels les transcrits évoluent dans des sens différents entre les conditions. Dans notre cas cependant, tous les gènes identifiés ainsi ont des transcrits se comportant de la même façon.

Il est difficile à ce point de faire ressortir une méthode par rapport à une autre, étant donné les limitations du jeu de données. Qualitativement cependant, en observant les expressions des transcrits des gènes identifiés, la méthode d'aggrégation Lancaster semble surtout identifier des gènes dont les transcrits sont tous différentiellement exprimés dans le même sens, tandis que les deux autres identifient des gènes dont l'isoforme majeur seulement varie.

## Perspective

En l'absence de données plus proches de celle que l'on pense obtenir à la fin du séquençage, il me semble plus prudent de conserver toutes ces méthodes dans notre analyse. Peut-être qu'une étape de simulation pour mieux discerner la meilleure de ces méthodes pourrait être pertinente, mais ce serait un projet potentiellement trop long pour le temps restant. Une alternative pour étudier le comportement de chacun de ces outils, surtout des deux qui résument l'information au niveau gène, serait d'établir une classification du type de gène identifié, comme : isoforme majeur uniquement, cancellation, collapsing, domination (classification de Yi et al)...
